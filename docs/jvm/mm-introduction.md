## Introduction
### Course Introduction
Hi, my name is Kevin. And this is the introduction chapter to the Understanding the Java Virtual Machine: Memory Management class. In this class, we're going to take a look at various aspects of garbage collection and memory management in the Java virtual machine, including how the GC works, how we can interact with the garbage collector, both from an external point of view, i.e. using some of the tools that the Java virtual machine provides for us, and also how we can interact with the garbage collector internally using some of the classes within the VM. Before we do that, I think it's good to understand why we need garbage collection at all. So in languages before Java, such a C and C++, whenever we allocated memory, so in this example where we allocate an object, at some point, we need to remember to delete that object and to free up that memory. If we didn't do that, we'd end up with a memory leak. In Java, that's not the case. So in Java, we can allocate an object, we can use it, and then when that object is no longer being referenced, the garbage collector will release the memory used by that project. There are also issues around who should delete an object. So here we call a method called getAccount that returns an account object. Who actually owns that object? Is it the receiver of the account object, so am I responsible for deleting it? Or is it the giver of the object, the thing that implements getAccount. If we're not clear about that, and neither side deletes the object, we end up with a memory leak. If we're not clear about that and both sides delete the object, we'll end up with some null pointer exception later down the line, which will be very, very hard track down. Finally, we can use objects with some confidence. So so long as I have a reference to an object, there's no way the garbage collector will free up that memory. I will always be able to hold onto that object and use it. In other environments, such a C++, a thread in the background may take a reference to that object and delete the object. When I then come to use it, I know of a pointer that's pointing at nothing, and I end up with either memory corruption or with the null pointer exception somewhere later in the code, again something else that's very, very hard to track down. Garbage collectors make a promise, and that promise is they claim no live objects. However, garbage collectors make no promise about dead objects. They may collect them. They may not that. If they do collect them, you don't know when they're going to run, i.e. when that memory is going to be reclaimed. So here, for example, we allocate an account object, we do new Account, and we have something that references a block of memory that contains that account object. If it's some later stage, we take that same variable, point it at a new account, you're now referencing a new piece of memory and a new Account object. The only guarantee that we have, and it's a good guarantee, is that that second account object will be live forever. So long as we have a reference to it, the garbage collector won't collect it. We have no guarantees about the old account object. It's no longer being referenced, and it may be reclaimed, but it may not. Even if we have an environment like Java where the garbage collector will run, we don't know when it will run, and we don't know that it'll run before the end of our application. So a quick note on Java versions for this course. So the world still runs on Java 8. Well, at least Java 8 is still widely used. However, this course is written on Java 11, but that's fine. I wanted to make sure that with this course, whether you're using Java 8 all the way through Java 11 or beyond, the course is still relevant for you. So certain things change. So, for example, in Java 7, the G1 garbage collector was introduced. It was actually produced in Java 6, but in Java 7, it was made official. In Java 6, it was just experimental. And then other things changed in Java 9. So in Java 9, the CMS garbage collector was deprecated, finalizers were deprecated, and something called the cleaner was introduced. But I still cover all of these things in the course. So I'll still mention finalizes because they're still widely used in Java 8. I still mention the CMS garbage collector because that's still widely used in Java 8. I talk about the G1 garbage collector because that's used from Java 7 onwards. And I talk about the cleaner because that's used from Java 9 onwards. So hopefully, whichever version of Java you're using, you'll find many useful things in the course.

### Different Types of Garbage Collection
There are also different types of garbage collection. So one type is do nothing. The garbage collector might just decide never to run, never to do anything, no memory gets freed, but we do still have the guarantee of not collecting live objects, and that's obviously a good thing. There's also reference counting garbage collection, and a good example of this is the COM programming environment. In COM, applications make calls to two functions, AddRef and Release. AddRef increments a count on an object, and Release decrements a count. When that count goes to 0, the object is no longer being referenced, and the object can now clean itself up and remove itself from memory. We have mark and sweep garbage collectors. With a mark and sweep garbage collector, when the garbage collector runs, it runs in two phases. The mark phase walks through all live memory, marking that memory as still being alive. And the sweep phase removes all unused memory. And this leaves us with memory that could be fragmented. We have a copying garbage collector, and typically with a copying garbage collector, this will work hand in hand with something like a mark and sweep collector. In this case, after the sweep phase, all the memory that's left is copied from one buffer to another. And at the same time, once the memory is being copied, we'll rearrange it so that it's no longer fragmented. We also have generational garbage collectors. The idea behind a generational garbage collector is that if an object survives a garbage collect, it's likely to be an object that's going to be around for a long time. In that case, once an object survives one garbage collect, the garbage collector may not look at it again for a while, and this improves the performance of the garbage collector. And finally, there's incremental garbage collectors. And in fact, the generational garbage collector is a form of incremental garbage collection. So an incremental garbage collector is a garbage collector that doesn't look at all the memory all the time during the garbage collect. And as we can see from this, garbage collectors tend not to be just of one type. So we tend to have a mixture of mark and sweep, copying, generational within a single garbage collector.

### Reference Counted Garbage Collection
I wanted to take a brief look at each of these forms of garbage collection in turn. Here we're showing the idea behind a reference counting garbage collector. So we have two objects here. The object on the left has a reference count of 2, and the object on the right has a reference count of 1. These objects are referencing each other, and that raises each other's reference count. This is called a circular reference, and this is one of the issues of the reference counting garbage collector. It's very hard to get rid of circle references. So, for example, once the reference on the left goes away, the count of both objects is now 1. Well, both these objects are actually garbage as there's no external reference to them, and this can be a very difficult problem to solve. The way reference counting works is that a given object once its been assigned will have its reference count incremented. And when it's being dereferenced in deassignment, it'll have the reference count decremented. When this reference count goes to 0, as in the first object here, the object is then freed. While the reference count is non‑0, then the object doesn't get freed. And also there are issues with this. People might forget to call AddRef, for example, i.e. to increment the reference count. They might forget to deref the object and decrement the reference count. So we can up with memory leaks. We can also end up with scenarios where somebody decrements the reference count, but the object is still in use. It's not the ideal situation.

### Mark and Sweep Garbage Collection
Mark and sweep garbage collectors actually typically have three phases, a mark phrase that identifies the objects that is still in use, a sweep phase that removes unused objects, and then a compact phase to compact the memory after all unused objects have been removed. Here we have a simple diagram of a block of memory. On the left, we have a root set of references. So these are references that we can follow from some root mechanism, maybe maybe the stack, that point at live memory. If we follow the references from the root set, any object that references another object also keeps that object alive. And in the mark phase, the garbage collector will start at the root set and walk through each object in turn, following all of its references, marking each object that's still alive in memory. Notice that we can have cycles here, and those cycles don't affect the garbage collector. So if one object references another, but there's no root reference to them, that memory can be collected. In the sweep phase, the garbage is taken away, and that leaves all the objects still in memory still being referenced. And then finally, this memory is compacted. So at this point, we've changed the physical addresses of the memory, and this is one important point to make about garbage collectors. In applications such as Java, we tend not have physical references to objects. We'll have some reference in our application, which the Java virtual machine internally will be able to use to get an actual physical location for that piece of memory. But it's very hard for us to actually get at that physical location. With the copying garbage collector, things are slightly different. There's still typically a mark phase and a sweep phase maybe. So here, for example, we have, a block of memory. This is allocated on the left, and this is where all of our current objects are being allocated. The way the garbage collector will work typically is when this block of memory called the fromspace becomes full, the garbage collector runs. Again, It follows the root set, and from the root set marks all the live objects. But now what happens during the sweep phase is these objects are moved into the tospace and so compacted at the same time. And then finally, the fromspace is cleared. The tospace and the fromspace are now swapped. The next piece of memory that gets allocated gets allocated in this new fromspace. And then finally, when that becomes full, the whole process happens again.

### Generational Garbage Collection
We also have the idea of generational garbage collectors, and the idea here is that once an object survives a garbage collection, that object is promoted to a different generation. The garbage collector will sweep through the young generations more often than it sweeps through the older generations. And depending on the environment, there could be any number of different generations. So in Java, for example, there's two. In .NET, there are three. Again. in different environments, there might be two or more generations where the garbage collector manages to collect memory. So with the generational garbage collector, again similar to before, we have a block of memory into which we're allocating our objects. And again, that memory has become full. This is now our first generation or young generation. In that generation, we've allocated memory. Notice we also have an old generation where there may be objects that may be alive, may not be alive. Once the GC runs, all the objects, in this case 1, 2, 3, and 4, that survive a garbage collect will be moved to the old generation. We can then clear the young generation and then carry on allocating objects inside the young generation.

### Demonstrating How the Garbage Collection Works
So what I'd like to do is to run some code that's going to allocate some memory and then take the address of that memory in Java and print out the address of the memory. And the idea behind this is that as we print these addresses, we'll see that the memory address rises as we allocate more and more objects. And then eventually, the garbage collector will run and, at that point, will collect all the memory. The next allocation will go back to the same address as the previous allocation or close to the previous allocation at least. We have some code here. Let me run this first, and then I'll take you through the code. So the application is called Sawtooth. It's very simple. We're going to run this with a classpath. And if I run this code, we just see it prints out a large stream of numbers. And at the moment, just by looking at those numbers, we can't see too much. But those numbers are the addresses of the objects as they are being allocated. So let me kill that. If I come back into the code, we can see how this is going to work. So we're allocating an object called GCMe. And GCMe is defined here. GCMe is simply a large object. There's many longs in here. In fact, there are 18 of them. So that makes this quite a large object. And the reason for that is that when we allocate this, if it was a small object, we need to allocate many, many thousands of them before the garbage collector kicked in. As it's larger, we need to allocate fewer objects before the garbage collector kicks in. So if I look at the code that allocates the objects, you'll see there's a loop. Inside the loop, we allocate a new object, GCMe. We take the address of the object, you'll see how we do that in a moment, and then simply print out that address. To take the address of the object, we have a helper method called addressOf that just gets given an object. And this helper uses the Unsafe class. Now Unsafe is part of sun.misc.Unsafe. This is not a standard part of the Java runtime. It's an undocumented class, but you'll find this used quite often, and it's quite possible that this class will be included officially in the Java 9 runtime. There are many websites out there that tell us how to use Unsafe. But essentially, we have to get a reference to a singleton class. We can't do that directly as the class is a private constructor, and there's also security checks in place to stop us creating instances of this class. Once we have a reference to the class, we can then use it to get the address of an object. And here we're just seeing if the address size is 4 or 8, so I'll be running on the 32‑bit environment or 64‑bit environment and then using either getInt to get the address or getLong to get the address. And we simply return that address. So that's all the code is doing. So if we run this code again, we'll see the same output, again not very interesting. But what I'd like to do is to run this code and capture that output to a file. And we'll give this file a CSV extension so it'll act like a comma‑separated variable file. So I'll just call this out.csv. Once that file has being created, we can check the contents by using cat on out.csv, and that displays the same date as we saw being printed to the console. Again, not very exciting. However, what we can do is load that data into Excel. So in Excel, if we open up out.csv, again, all we see is a column of numbers. Now what we can do is if I highlight that column and insert a line graph, so I go to Graphs, Line, and that'll take that data. And as we can see, we got a sawtooth graph. And what this is showing is that we start allocating memory at a certain place inside the address space. We keep allocating, allocating, allocating, allocating. Eventually, we'll try and allocate some memory. We'll have no more space to allocate it. The garbage collector will kick in, that will free up the memory, and the next time we allocate memory is at some lower location inside the address space. And again, we run through the same process. We keep allocating until the garbage collector kicks in. And then when that happens, we run again, the GC runs, and we allocate the next piece of memory at the lowest point inside the address space, and off we go again. So hopefully this illustrates very simply what the GC is doing inside this application. We'll see later in this course that a far more sophisticated tool is out there for showing the garbage collector, but this is a nice, simple approach for showing what's happening.